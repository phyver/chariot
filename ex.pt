(* type of natural numbers *)
data nat where Zero : nat | Succ : nat -> nat

(* type of lists and branching trees *)
data
  list('x) where Nil : list('x)
              | Cons : 'x -> list('x) -> list('x)
and
  tree('b,'x,'y) where
    | Leaf : 'y → tree('b,'x,'y)
    | Node : 'x → ('b → tree('b,'x,'y)) → tree('b,'x,'y)

(* length of a list *)
val length : list('x) -> nat
    | length Nil = Zero
    | length (Cons x xs) = Succ (length xs)

(* addition of natural numbers *)
val add : nat -> nat -> nat  | add n Zero = n | add n (Succ m) = Succ (add n m)

val mult : nat -> nat -> nat | mult n Zero = Zero | mult n (Succ m) = add n (mult n m)

val pow : nat -> nat -> nat | pow n Zero = Succ Zero | pow n (Succ m) = mult n (pow n m)



(* rose trees *)
data rtree where Fork : list(rtree) -> rtree


(* size of a tree *)
val size : rtree -> nat
  | size (Fork Nil) = Zero
  | size (Fork (Cons t ts)) = add (size t) (size (Fork ts))


(* coinductive type: streams *)
codata stream('x) where
    | Head : stream('x) -> 'x
    | Tail : stream('x) -> stream('x)


  (* map on streams *)
val map : ('x -> 'y) -> stream('x) -> stream('y)
    | (map f s).Head = f (s.Head)
    | (map f s).Tail = map f s.Tail

(* oops... I need the booleans *)
data bool where True : bool | False : bool

(* and I can define mutually recursive functions" *)
val
  even : nat -> bool
      | even Zero = True
      | even (Succ n) = odd n
and
  odd : nat -> bool
      | odd Zero = False
      | odd (Succ n) = even n

(* using the daimon *)
val oops : 'a -> 'b
  | oops a = !!!

val oops2 : 'a -> 'b
  | oops2 =!!!


(* show all the defined types *)
:show types

(* show all the defined functions *)
:show functions

(* test compute *)
:reduce (pow (Succ(Succ(Succ Zero))) (pow (Succ(Succ Zero)) (Succ(Succ Zero))))

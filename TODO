  - use case_struct terms for computation

  - check that constructor are fully applied in patterns

  - change type used for representing calls for SCT:
        type sct_clause = (var_name * approx_term list) * (var_name * approx_term list)

  - use lexing positions for parsing errors:
      - update "file" field
      - print buffer with error underlined ???

  - use type weight for priorities

  - allow parser to read priorities in terms for testing...

  - README file

  - use DeCap?

  - remove Proj variant and use Const everywhere (requires thinking about
    priority None: there should be a data and codata version)

  - pygmentize / highlight to get colors???

  - allow "{ proj1 = u1 ; ... ; projn = un }" in terms and patterns (=> lexer,
    parser, term, ...) unification now has
        { proj1 = u1 ; ... ; projn = un } ~ t   ==>   u1 ~ t.proj1, ..., un ~ t.projn

    In the end, the substitution should only contain "simple" patterns, and
    substitution should use "simple pattern matching"



  - use a special variable "Var "()" when collapsing constants

  - change type used for representing calls for SCT:
        type sct_clause = (var_name * approx_term list) * (var_name * approx_term list)


  - convert definitions to CaseStruct terms for exhaustivity checking (it is broken at the moment)

  - use DeCap?

  - add types to all subterms: type ('a,'b) special_term instantiated with
    'a:=empty and 'b:=unit or 'b:=type_expression, etc.

  - use lexing positions for parsing errors:
      - update "file" field
      - print buffer with error underlined ???

  - use type weight for priorities

  - move file commands.ml to parser.ml and remove type command

  - remove Proj variant and use Const everywhere (requires thinking about
    priority None: there should be a data and codata version)

  - pygmentize / highlight to get colors???

  - allow "{ proj1 = u1 ; ... ; projn = un }" in terms and patterns (=> lexer,
    parser, term, ...) unification now has
        { proj1 = u1 ; ... ; projn = un } ~ t   ==>   u1 ~ t.proj1, ..., un ~ t.projn

    In the end, the substitution should only contain "simple" patterns, and
    substitution should use "simple pattern matching"



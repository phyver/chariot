>> option verbose is set to 1
>> option show_tuples is set to false
>> option verbose is set to 1
>> option allow_structs is set to true
>> option continue_on_error is set to true
>> inductive type nat was succesfully defined
>> inductive type prod_2 was succesfully defined
>> coinductive type struct_2 was succesfully defined
>> Typing for s01, _aux₁ successful
>> the definition for s01 is complete
>> the definition for _aux₁ is complete
>> the definitions s01, _aux₁ are provably correct

>> Typing for s012, _aux₂, _aux₃ successful
>> the definition for s012 is complete
>> the definition for _aux₂ is complete
>> the definition for _aux₃ is complete
>> the definitions s012, _aux₂, _aux₃ are provably correct

>> Typing for s0101, _aux₄ successful
>> the definition for s0101 is complete
>> the definition for _aux₄ is complete
>> the definitions s0101, _aux₄ are provably correct

** error: pattern is not linear: variable x appears more than once
>> Typing for f successful
>> the definition for f is complete
>> the definition f is provably correct

>> Typing for g, _aux₆ successful
>> the definition for g is complete
>> the definition for _aux₆ is complete
>> the definitions g, _aux₆ are provably correct

>> Typing for h, _aux₇, _aux₈ successful
>> the definition for h is complete
>> the definition for _aux₇ is complete
>> the definition for _aux₈ is complete
>> the definitions h, _aux₇, _aux₈ are provably correct

>> Typing for s, _aux₁₀, _aux₁₁, _aux₁₂, _aux₉ successful
>> the definition for s is complete
>> the definition for _aux₁₀ is complete
>> the definition for _aux₁₁ is complete
>> the definition for _aux₁₂ is complete
>> the definition for _aux₉ is complete
>> the definitions s, _aux₁₀, _aux₁₁, _aux₁₂, _aux₉ are provably correct

>> coinductive type stream was succesfully defined
>> Typing for map, _aux₁₃, _aux₁₄ successful
>> the definition for map is complete
>> the definition for _aux₁₃ is complete
>> the definition for _aux₁₄ is complete
>> the definitions map, _aux₁₃, _aux₁₄ are provably correct

>> functions in environment:
val
   s01 : struct_2(nat,nat)
    | s01 = _aux₁
and
   _aux₁ : struct_2(nat,nat)
    | _aux₁.Fst² = 0
    | _aux₁.Snd² = 1

val
   s012 : struct_2(nat,struct_2(nat,nat))
    | s012 = _aux₂
and
   _aux₂ : struct_2(nat,struct_2(nat,nat))
    | _aux₂.Fst² = 0
    | _aux₂.Snd⁴ = _aux₃
and
   _aux₃ : struct_2(nat,nat)
    | _aux₃.Fst² = 1
    | _aux₃.Snd² = 2

val
   s0101 : struct_2(struct_2(nat,nat),struct_2(nat,nat))
    | s0101 = _aux₄
and
   _aux₄ : struct_2(struct_2(nat,nat),struct_2(nat,nat))
    | _aux₄.Fst⁴ = s01
    | _aux₄.Snd⁴ = s01

val
   f : struct_2('a,'b) → prod_2('a,'b)
    | f p = Tuple_2¹ p.Fst² p.Snd²

val
   g : struct_2('a,'b) → prod_2('a,'b)
    | g x₁ = _aux₆ x₁.Fst² x₁.Snd²
and
   _aux₆ : 'a → 'b → prod_2('a,'b)
    | _aux₆ x y = Tuple_2¹ x y

val
   h : struct_2('a,struct_2('b,'c)) → prod_2(prod_2('a,'b),'c)
    | h x₁ = _aux₇ x₁.Fst⁴ x₁.Snd⁴
and
   _aux₇ : 'a → struct_2('b,'c) → prod_2(prod_2('a,'b),'c)
    | _aux₇ x₁ x₂ = _aux₈ x₁ x₂.Fst² x₂.Snd²
and
   _aux₈ : 'a → 'b → 'c → prod_2(prod_2('a,'b),'c)
    | _aux₈ x y z = Tuple_2³ (Tuple_2¹ x y) z

val
   s : struct_2('a,struct_2('b,'c)) → struct_2(struct_2('a,'b),'c)
    | s x₁ = _aux₉ x₁.Fst⁴ x₁.Snd⁴
and
   _aux₁₀ : 'a → 'b → 'c → struct_2(struct_2('a,'b),'c)
    | _aux₁₀ x y z = _aux₁₁ x y z
and
   _aux₁₁ : 'a → 'b → 'c → struct_2(struct_2('a,'b),'c)
    | (_aux₁₁ x y z).Fst² = _aux₁₂ x y
    | (_aux₁₁ x y z).Snd⁴ = z
and
   _aux₁₂ : 'a → 'b → struct_2('a,'b)
    | (_aux₁₂ x y).Fst² = x
    | (_aux₁₂ x y).Snd² = y
and
   _aux₉ : 'a → struct_2('b,'c) → struct_2(struct_2('a,'b),'c)
    | _aux₉ x₁ x₂ = _aux₁₀ x₁ x₂.Fst² x₂.Snd²

val
   map : ('a → 'b) → stream('a) → stream('b)
    | map x₁ x₂ = _aux₁₃ x₁ x₂.Head² x₂.Tail²
and
   _aux₁₃ : ('a → 'b) → 'a → stream('a) → stream('b)
    | _aux₁₃ f x s = _aux₁₄ f s x
and
   _aux₁₄ : ('a → 'b) → stream('a) → 'a → stream('b)
    | (_aux₁₄ f s x).Head² = f x
    | (_aux₁₄ f s x).Tail² = map f s


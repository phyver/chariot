>> option verbose is set to 1
>> option show_lists is set to false
>> option show_nats is set to false
>> inductive type nat was succesfully defined
>> inductive type unit was succesfully defined
>> inductive type prod_2 was succesfully defined
>> Typing for fst successful
>> the definition for fst is complete
>> the definition fst is provably correct

>> Typing for snd successful
>> the definition for snd is complete
>> the definition snd is provably correct

>> Typing for pair successful
>> the definition for pair is complete
>> the definition pair is provably correct

>> inductive type list was succesfully defined
>> Typing for onetwothree successful
>> the definition for onetwothree is complete
>> the definition onetwothree is provably correct

>> Typing for pairs successful
>> the definition for pairs is complete
>> the definition pairs is provably correct

>> functions in environment:
val
    fst : ('a * 'b) → 'a
  | fst (x, y) = x

val
    snd : ('a * 'b) → 'b
  | snd (x, y) = y

val
    pair : nat * nat
  | pair = (Zero², Zero²)

val
    onetwothree : list(nat)
  | onetwothree = Cons² (Succ⁴ Zero⁴, Cons² (Succ⁴ (Succ⁴ Zero⁴), Cons² (Succ⁴ (Succ⁴ (Succ⁴ Zero⁴)), Nil² ())))

val
    pairs : nat * (nat * (nat * nat))
  | pairs = (Succ⁶ Zero⁶, (Succ⁶ (Succ⁶ Zero⁶), (Succ⁶ (Succ⁶ (Succ⁶ Zero⁶)), Succ⁶ (Succ⁶ (Succ⁶ (Succ⁶ Zero⁶))))))

>> inductive type prod_3 was succesfully defined
>> Typing for test successful
>> the definition for test is complete
>> the definition test is provably correct

val
    test : nat * nat * nat
  | test = (Succ² Zero², Succ² (Succ² Zero²), Succ² (Succ² (Succ² Zero²)))

>> option continue_on_error is set to true
** error: cannot infer type of constant Tuple_4
>> option show_tuples is set to false
>> functions in environment:
val
    fst : prod_2('a,'b) → 'a
  | fst (Tuple_2⁰ x y) = x

val
    snd : prod_2('a,'b) → 'b
  | snd (Tuple_2⁰ x y) = y

val
    pair : prod_2(nat,nat)
  | pair = Tuple_2⁰ Zero² Zero²

val
    onetwothree : list(nat)
  | onetwothree = Cons² (Tuple_2⁰ (Succ⁴ Zero⁴) (Cons² (Tuple_2⁰ (Succ⁴ (Succ⁴ Zero⁴)) (Cons² (Tuple_2⁰ (Succ⁴ (Succ⁴ (Succ⁴ Zero⁴))) (Nil² Tuple_0⁰))))))

val
    pairs : prod_2(nat,prod_2(nat,prod_2(nat,nat)))
  | pairs = Tuple_2⁰ (Succ⁶ Zero⁶) (Tuple_2² (Succ⁶ (Succ⁶ Zero⁶)) (Tuple_2⁴ (Succ⁶ (Succ⁶ (Succ⁶ Zero⁶))) (Succ⁶ (Succ⁶ (Succ⁶ (Succ⁶ Zero⁶))))))

val
    test : prod_3(nat,nat,nat)
  | test = Tuple_3⁰ (Succ² Zero²) (Succ² (Succ² Zero²)) (Succ² (Succ² (Succ² Zero²)))

